classdef splitCoder < handle
  
  properties
    f = -1; % File handle to write the code to
    
    % Constants needed at compile time
    rho = 1.0;
    
    % Data defining the problem
    data = struct([]);
    
    % Functions that will be generated
    genFuncs = {...
      'custom_compute_parametric',...
      'custom_mult_Ltrans',...
      'custom_mult_L',...
      'custom_prox',...
      'custom_solve_kkt',...
      };
    
    % C-file and header (strings)
    c_str = {};
    h_str = {};
    
    constants = struct([]);
    
    id = 1; % Unique ID used to generate constants
    
    sparseProdLimit = 0.1; % Percentage sparsity before we use dense multiplication
  end
  
  methods
    function cdr = splitcoder(prob)
      cdr.parseProb(prob); % Parse basic data
    end
    
    function gen(cdr)
      cdr.id = 1;
      cdr.constants = struct([]);
      
      % Generate probData.c containing the problem data
      cdr.f = fopen('probData.c', 'w+');
      
      cdr.gen_header();
      
      for i = 1:length(cdr.genFuncs)
        eval(['cdr.' cdr.genFuncs{i} ';'])
      end
      
      fclose(cdr.f);
    end
  end
  
  methods(Hidden=true, Access=private)
    parseProb(cdr, prob)
    genMatVecProduct(cdr,y,x,A,Astr,b,bstr)

    function p(cdr, varargin)
      % Print the string to the file
      fprintf(cdr.f, varargin{:});
    end
    function pl(cdr, varargin)
      % Print the string to the file, with a newline
      if ~isempty(varargin)
        varargin{1} = [varargin{1} '\n']; 
      else
        varargin{1} = '\n';
      end
      cdr.p(varargin{:});
    end
    
    function name = define_constant(cdr, name, val)
      % Add a new constant to be written to the file
      % val must be a vector
      % name will be modifies to ensure that its unique
      
      name = sprintf('%s_%i', name, cdr.getID());
      cdr.constants(end+1).name = name;
      cdr.constants(end).val = val;
    end
    
    function id = getID(cdr)
      % Get unique ID
      id = cdr.id;
      cdr.id = cdr.id + 1;
    end
    
    % Print the header
    function gen_header(cdr)
      dat = cdr.data;
      cdr.pl('/**********************************************************');
      cdr.pl(' * Problem data file');
      cdr.pl(' * ');
      cdr.pl(' * Automatically generated by SPLIT on %s', char(datetime));
      cdr.pl(' **********************************************************/');
      cdr.pl
      cdr.pl('#include "matrix_ops.h"')
      cdr.pl;
      cdr.pl('#define  nParam  %i', size(dat.pL,2));
      cdr.pl('#define  nPrimal %i', size(dat.A,2));
      cdr.pl('#define  nDual   %i', size(dat.L,1));
      cdr.pl('#define  nEqCon  %i', size(dat.A,1));
      cdr.pl;
    end
    
    function custom_compute_parametric(cdr)
      dat = cdr.data;
      cdr.pl;
      cdr.pl('void custom_compute_parametric(double l[nDual], double f[nPrimal], double b[nEqCon], double par[nParam])')
      cdr.pl('{')
      cdr.genMatVecProduct('l','par',dat.pL,'pL',dat.l,'l');
      cdr.genMatVecProduct('f','par',dat.pF,'pF',dat.f,'f');
      cdr.genMatVecProduct('b','par',dat.pB,'pB',dat.b,'b');
      cdr.pl('}')
      cdr.pl;
    end
    
    % y = L'*x
    function custom_mult_Ltrans(cdr)
      dat = cdr.data;
      cdr.pl;
      cdr.pl('void custom_mult_Ltrans(double y[nPrimal], double x[nDual])')
      cdr.pl('{')
      cdr.genMatVecProduct('y','x',dat.L','Ltrans',0);
      cdr.pl('}')
      cdr.pl;
    end
    
    % y = L*x
    function custom_mult_L(cdr)
      dat = cdr.data;
      cdr.pl;
      cdr.pl('void custom_mult_L(double y[nDual], double x[nPrimal])')
      cdr.pl('{')
      cdr.genMatVecProduct('y','x',dat.L,'L',0);
      cdr.pl('}')
      cdr.pl;
    end
    
    % Evaluate prox functions y = prox(x)
    function custom_prox(cdr)
      dat = cdr.data;
      cdr.pl;
      cdr.pl('void custom_prox(double y[nDual], double x[nDual])')
      cdr.pl('{')
     
      for i = 1:length(cdr.data.prox)
        prox = cdr.data.prox(i);
        args = sprintf('y+%i, x+%i', prox.ind, prox.ind);
        switch prox.type
          case 'box',                 error ('Prox not implemented yet');
          case 'ellipse',             error ('Prox not implemented yet');
          case 'ellipseConj',         error ('Prox not implemented yet');
          case 'secondOrderCone'
            cdr.pl('proj_secondOrderCone(%s, %i);',args, prox.len)
          case 'secondOrderConeConj', error ('Prox not implemented yet');
          case 'nonPositive',        
            cdr.pl('proj_negative(%s, %i);',args, prox.len)
          case 'nonNegative',         
            cdr.pl('proj_positive(%s, %i);',args, prox.len)
          case 'normBall'
            switch prox.dat.p
              case 1,    funcName = 'proj_normball_one';
              case 2,    funcName = 'proj_normball_two';
              case inf,  funcName = 'proj_normball_inf';
              otherwise, error('Unkown norm-type')
            end
            cdr.pl('%s(%s, %g, %i);', funcName, args, prox.dat.c, prox.len)
          case 'normProx',            
            switch prox.dat.p
              case 1,    funcName = 'prox_norm_one';
              case 2,    funcName = 'prox_norm_two';
              case inf,  funcName = 'prox_norm_inf';
              otherwise, error('Unkown norm-type')
            end
            cdr.pl('%s(%s, rho, %i);', funcName, args, prox.len)
          otherwise
            error('Unknown prox type')
        end
        
      end
      cdr.pl('}')
      cdr.pl;
    end
    
    % Solve the KKT system K \ x = b
    function custom_solve_kkt(cdr)
      cdr.pl;
      cdr.pl('void custom_solve_kkt(double x[nPrimal+nEqCon], double b[nPrimal+nEqCon])')
      cdr.pl('{')

      % Assumes that the KKT matrix is constant
      Q   = cdr.data.Q;
      rho = cdr.rho;
      L   = cdr.data.L;
      A   = cdr.data.A;      
      K = [Q+rho*L'*L A'; A zeros(size(A,1))];
      
      % Two possible solve methos:
      % LDL and direct multiplication by matrix inverse
      iK = inv(K);
      density = nnz(iK) / prod(size(iK));
%       if density < 0.2 % TODO: Replace magic number
        % Density is low => Do sparse multiplication
        cdr.genMatVecProduct('x','b',iK,'iK');
%       else
        % Density is high => Do forward-backward solve with LDL
        
        
%       end
      
      cdr.pl('}')
      cdr.pl;
    end
  end
end
